<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width">
    <title></title>

    <link rel="manifest" href="manifest.json">

    <!-- un-comment this code to enable service worker
    <script>
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('service-worker.js')
          .then(() => console.log('service worker installed'))
          .catch(err => console.log('Error', err));
      }
    </script>-->

    <link href="lib/ionic/css/ionic.css" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet">

    <!-- IF using Sass (run gulp sass first), then uncomment below and remove the CSS includes above
    <link href="css/ionic.app.css" rel="stylesheet">
    -->

    <!-- ionic/angularjs js -->
    <script src="lib/ionic/js/ionic.bundle.js"></script>

    <!-- cordova script (this will be a 404 during development) -->
    <script src="cordova.js"></script>

    <!-- your app's js -->
    <script src="js/app.js"></script>
    <script src="js/controllers.js"></script>
    <script src="js/services.js"></script>


    <!-- Tracking scripts -->
    <script src="js/p5.js"></script>
    <script src="js/p5.dom.js"></script>
    <script src="js/jsfeat-min.js"></script>

    <link rel="stylesheet" href="https://i.icomoon.io/public/temp/0834541b87/UntitledProject/style.css">


  </head>
  <body ng-app="starter">
    <!--
      The nav bar that will be updated as we navigate between views.
    -->
    <ion-nav-bar class="bar-stable">
      <ion-nav-back-button>
      </ion-nav-back-button>
    </ion-nav-bar>
    <!--
      The views will be rendered in the <ion-nav-view> directive below
      Templates are in the /templates folder (but you could also
      have templates inline in this html file if you'd like).
    -->
    <ion-nav-view></ion-nav-view>

    <script type="text/javascript">
      console.log("Loading tracker")

      var cnv;
      var capture;
      var curpyr, prevpyr, pointCount, pointStatus, prevxy, curxy;
      var w = 360,
          h = 260;
      var maxPoints = 10;

      function setup() {
          const canvasHolder = select('#canvasHolder');


          if(canvasHolder){
            capture = createCapture(VIDEO);
            cnv = createCanvas(w, h).parent('canvasHolder');
            capture.size(w, h);
            capture.hide();

            curpyr = new jsfeat.pyramid_t(3);
            prevpyr = new jsfeat.pyramid_t(3);
            curpyr.allocate(w, h, jsfeat.U8C1_t);
            prevpyr.allocate(w, h, jsfeat.U8C1_t);

            pointCount = 0;
            pointStatus = new Uint8Array(maxPoints);
            prevxy = new Float32Array(maxPoints * 2);
            curxy = new Float32Array(maxPoints * 2);
          }
      }

      function keyPressed(key) {
          for (var i = 0; i < 100; i++) {
              addPoint(random(width), random(height));
          }
      }

      function mousePressed() {
          addPoint(mouseX, mouseY);
      }

      function addPoint(x, y) {
          if (pointCount < maxPoints) {
              var pointIndex = pointCount * 2;
              curxy[pointIndex] = x;
              curxy[pointIndex + 1] = y;
              pointCount++;
          }
      }

      function prunePoints() {
          var outputPoint = 0;
          for (var inputPoint = 0; inputPoint < pointCount; inputPoint++) {
              if (pointStatus[inputPoint] == 1) {
                  if (outputPoint < inputPoint) {
                      var inputIndex = inputPoint * 2;
                      var outputIndex = outputPoint * 2;
                      curxy[outputIndex] = curxy[inputIndex];
                      curxy[outputIndex + 1] = curxy[inputIndex + 1];
                  }
                  outputPoint++;
              }
          }
          pointCount = outputPoint;
      }

      function draw() {
          var pointX = document.getElementById("pointX");
          if(pointX){pointX.textContent = "Point X = " + Math.floor(curxy[0])}

          var pointY = document.getElementById("pointY");
          if(pointY){pointY.textContent = "Point Y = " + Math.floor(curxy[1])}


          image(capture, 0, 0, w, h);
          capture.loadPixels();
          if (capture.pixels.length > 0) { // don't forget this!
              var xyswap = prevxy;
              prevxy = curxy;
              curxy = xyswap;
              var pyrswap = prevpyr;
              prevpyr = curpyr;
              curpyr = pyrswap;

              // these are options worth breaking out and exploring
              var winSize = 20;
              var maxIterations = 30;
              var epsilon = 0.01;
              var minEigen = 0.001;

              jsfeat.imgproc.grayscale(capture.pixels, w, h, curpyr.data[0]);
              curpyr.build(curpyr.data[0], true);
              jsfeat.optical_flow_lk.track(
                  prevpyr, curpyr,
                  prevxy, curxy,
                  pointCount,
                  winSize, maxIterations,
                  pointStatus,
                  epsilon, minEigen);
              prunePoints();

              for (var i = 0; i < pointCount; i++) {
                  var pointOffset = i * 2;
                  ellipse(curxy[pointOffset], curxy[pointOffset + 1], 8, 8);
              }
          }
      }
</script>
  </body>
</html>
